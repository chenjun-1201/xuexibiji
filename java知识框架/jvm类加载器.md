# jvm类加载器

什么是类加载器：

当程序被javac编译成.class文件后，类加载器将.class编译成机器识别的二进制文件

- AppClassLoader ：应用类加载器   加载classpath下的类
- ExtClassLoader：扩展类加载器    加载/jre/lib/ext中的类
- BootStrap：根加载器，加载/jre/lib/rt.jar中的类



双亲委派机制：

app--->ext--->--->Bootstartp(最终执行)  --->如果没有找到类就递归往下找最终找到对应的加载器进行调用

当.class文件需要被类加载加载时，会递归向上调用父亲的类加载器，当类加载器没有找到我们的类加载器时，才会调用我们的类加载器AppClassLoader







什么是jvm：

JVM是JRE的一部分

 跨平台特性：通过java虚拟机中的java解释器转换文件解释成为特定的机器码进行运行。（转换成Linux ，Windows，Linux能识别的内容）



![屏幕快照 2020-08-20 20.54.33](/Users/mac/Desktop/屏幕快照 2020-08-20 20.54.33.png)



结构划分

- 类装载器：

- 运行数据区
  - 方法区：
  - 堆
  - 虚拟机栈
  - 本地方法栈
  - 程序计数寄存器
- 本地方法接口







堆(heap)

- 新生区
  - 伊甸园区
  - 幸存区0
  - 幸存区1
- 养老区
- 永久区（元空间）



oom：堆内存满了

Exception in thread "main" java.lang.OutOfMemoryError: Java heap space







## Gc垃圾回收



常见问题：

- Gc算法有哪些？

  - 复制算法

  - **标记-清除**： 先标记出需要清除的对象，再将标记的对象回收， 优点：占用内存小

  - **标记-压缩**：先标记出需要清除的对象，但是不进行回收，而是让所有存活对象都向一段移动，然后清除边界之外的内存空间。

     优点：占用内存小，没有内存碎片   ，缺点：效率低

  - **分代收集**： 根据Java堆的新生代和老年代的特点，选用不同的回收算法。新生代内存空间大，对象会大量死去，回收频繁，使用效率高的复制算法，只需要每次复制少量存活下来的对象即可。老年代内存空间小，对象存活率高，使用标记-清除/标记-压缩算法。

- Gc的内存模型和分区



- 轻Gc和重Gc分别在什么时候发生
- 轻Gc：Eden区域满了，或者新创建的对象大小 > Eden所剩空间
- 重Gc：是清理整个堆空间—包括年轻代和永久代。FullGC 一般消耗的时间比较长，远远大于MinorGC，

